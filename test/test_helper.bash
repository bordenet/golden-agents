#!/usr/bin/env bash
# Test helper functions for generate-agents.sh BATS tests
# Updated 2026-02-02 for scenario-based testing with size and data loss verification

# Get the directory containing the script under test
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
GENERATE_SCRIPT="$SCRIPT_DIR/generate-agents.sh"
FIXTURES_DIR="$SCRIPT_DIR/test/fixtures"

# Load bats helper libraries if available
if [[ -d "$SCRIPT_DIR/test/test_helper/bats-support" ]]; then
    load 'test_helper/bats-support/load'
fi
if [[ -d "$SCRIPT_DIR/test/test_helper/bats-assert" ]]; then
    load 'test_helper/bats-assert/load'
fi

# ========== SIZE ENFORCEMENT (CRITICAL) ==========

# HARD LIMIT: Progressive mode must be under this
MAX_PROGRESSIVE_LINES=100

# HARD LIMIT: Compact mode must be under this
MAX_COMPACT_LINES=200

# Assert output is within size limits for progressive mode
assert_progressive_size() {
    local file="$1"
    local line_count
    line_count=$(wc -l < "$file" | tr -d ' ')
    if [[ "$line_count" -gt "$MAX_PROGRESSIVE_LINES" ]]; then
        echo "FAIL: Progressive mode generated $line_count lines (max: $MAX_PROGRESSIVE_LINES)" >&2
        echo "This is RUBBISH. AI assistants cannot follow files this large." >&2
        return 1
    fi
}

# Assert output is within size limits for compact mode
assert_compact_size() {
    local file="$1"
    local line_count
    line_count=$(wc -l < "$file" | tr -d ' ')
    if [[ "$line_count" -gt "$MAX_COMPACT_LINES" ]]; then
        echo "FAIL: Compact mode generated $line_count lines (max: $MAX_COMPACT_LINES)" >&2
        echo "This is RUBBISH. Files over 200 lines are not 'compact'." >&2
        return 1
    fi
}

# ========== DATA LOSS VERIFICATION (CRITICAL) ==========

# Count unique non-empty, non-whitespace lines (for content comparison)
count_unique_content_lines() {
    local file="$1"
    grep -v '^[[:space:]]*$' "$file" | sort -u | wc -l | tr -d ' '
}

# Assert specific content marker is preserved
assert_content_preserved() {
    local file="$1"
    local marker="$2"
    local context="${3:-unknown operation}"

    if ! grep -q "$marker" "$file"; then
        echo "FAIL: Content lost in $context" >&2
        echo "  Missing: $marker" >&2
        return 1
    fi
}

# ========== FIXTURE HELPERS ==========

# Create a minimal valid Agents.md WITH markers (v1.2.0+ style)
create_agents_with_markers() {
    local path="$1"
    local lang="${2:-go}"
    local type="${3:-cli-tools}"
    local mode="${4:-compact}"

    mkdir -p "$path"
    cat > "$path/Agents.md" << EOF
# AI Agent Guidelines - TestProject

> **Generated by**: [golden-agents](https://github.com/bordenet/golden-agents) v1.2.1 (${mode})
> **Last Updated**: 2026-02-01
> **Languages**: ${lang}
> **Type**: ${type}

Self-contained. Minimal high-signal tokens.
<!-- GOLDEN:framework:start -->

---

## Superpowers Integration

At the START of every conversation, run:

\`\`\`bash
node ~/.codex/superpowers-augment/superpowers-augment.js bootstrap
\`\`\`

<!-- GOLDEN:framework:end -->

---

## Project-Specific Rules

<!-- Add project-specific guidance below this line -->

### My Custom Rule
Always use feature branches for new work.

### Team Conventions
- PR requires 2 approvals
- Use conventional commits
EOF
}

# Create Agents.md WITHOUT markers (pre-v1.2.0 style)
create_agents_without_markers() {
    local path="$1"
    mkdir -p "$path"
    cat > "$path/Agents.md" << EOF
# AI Agent Guidelines - TestProject

## Some guidance
This file has no markers and was created before v1.2.0.

## Project Rules
- Do something
- Do something else
EOF
}

# Create Agents.md with full mode header (no "(compact)" in header)
create_agents_full_mode() {
    local path="$1"
    local lang="${2:-go}"

    mkdir -p "$path"
    cat > "$path/Agents.md" << EOF
# AI Agent Guidelines - TestProject

> **Generated by**: [golden-agents](https://github.com/bordenet/golden-agents) v1.2.1
> **Last Updated**: 2026-02-01
> **Languages**: ${lang}
> **Type**: cli-tools

<!-- GOLDEN:framework:start -->
## Framework content (full mode)
<!-- GOLDEN:framework:end -->

## Project-Specific Rules
Custom content here.
EOF
}

# Create bloated fixture (simulates old full-mode file)
create_bloated_fixture() {
    local path="$1"
    local lines="${2:-600}"
    local lang="${3:-go}"

    mkdir -p "$path"
    {
        echo "# AI Agent Guidelines"
        echo ""
        echo "> **Auto-generated by Golden Agents Framework**"
        echo "> **Languages**: ${lang}"
        echo "> **Type**: cli-tools"
        echo ""
        echo "<!-- GOLDEN:framework:start -->"

        # Generate bloated framework content
        for i in $(seq 1 "$lines"); do
            echo "Framework line $i with some padding content here"
        done

        echo "<!-- GOLDEN:framework:end -->"
        echo ""
        echo "## Project-Specific Rules"
        echo ""
        echo "### Custom Rule 1"
        echo "UNIQUE_MARKER_CUSTOM_RULE_1"
        echo ""
        echo "### Custom Rule 2"
        echo "UNIQUE_MARKER_CUSTOM_RULE_2"
    } > "$path/Agents.md"
}

# Create realistic CLAUDE.md for migration testing
create_realistic_claude_md() {
    local path="$1"

    mkdir -p "$path"
    cat > "$path/CLAUDE.md" << 'EOF'
# Project AI Guidelines

> Last Updated: 2026-01-15

## Build Commands

```bash
npm run build
npm run test
npm run lint
```

## Architecture

This project uses a three-tier architecture:

1. **Frontend**: React with TypeScript
2. **Backend**: Go microservices
3. **Database**: PostgreSQL

UNIQUE_MARKER_ARCHITECTURE

## Development Conventions

### Git Workflow
- Feature branches from main
- PR requires 2 approvals
- Squash merge only

UNIQUE_MARKER_GIT_WORKFLOW

### Code Style
- Use Prettier for formatting
- ESLint for linting
- Go fmt for Go code

UNIQUE_MARKER_CODE_STYLE

## Testing Requirements

- Unit tests required for all new code
- Integration tests for API endpoints
- E2E tests for critical flows

UNIQUE_MARKER_TESTING

## AI Behavior Rules

- Never expose API keys
- Always use environment variables for secrets
- Check for security vulnerabilities before committing

UNIQUE_MARKER_AI_BEHAVIOR

## Custom Domain Knowledge

This is project-specific knowledge that must be preserved:
- The Validation Dashboard uses terminal UI
- Recipe Capture has three tiers
- AppLogger uses specific patterns

UNIQUE_MARKER_DOMAIN_KNOWLEDGE
EOF
}

# ========== BASIC ASSERTIONS ==========

# Assert file contains pattern
assert_file_contains() {
    local file="$1"
    local pattern="$2"
    if ! grep -q "$pattern" "$file"; then
        echo "FAIL: File '$file' does not contain: $pattern" >&2
        echo "File contents:" >&2
        cat "$file" >&2
        return 1
    fi
}

# Assert file does NOT contain pattern
assert_file_not_contains() {
    local file="$1"
    local pattern="$2"
    if grep -q "$pattern" "$file"; then
        echo "FAIL: File '$file' should not contain: $pattern" >&2
        return 1
    fi
}

# Assert file exists
assert_file_exists() {
    local file="$1"
    if [[ ! -f "$file" ]]; then
        echo "FAIL: File '$file' does not exist" >&2
        return 1
    fi
}

# Assert directory exists
assert_dir_exists() {
    local dir="$1"
    if [[ ! -d "$dir" ]]; then
        echo "FAIL: Directory '$dir' does not exist" >&2
        return 1
    fi
}

# Get line count of file
get_line_count() {
    local file="$1"
    wc -l < "$file" | tr -d ' '
}

# Assert line count is within range
assert_line_count_between() {
    local file="$1"
    local min="$2"
    local max="$3"
    local count
    count=$(get_line_count "$file")
    if [[ "$count" -lt "$min" || "$count" -gt "$max" ]]; then
        echo "FAIL: File '$file' has $count lines, expected between $min and $max" >&2
        return 1
    fi
}


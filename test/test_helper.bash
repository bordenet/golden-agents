#!/usr/bin/env bash
#
# test_helper.bash - BATS Test Helper Functions
#
# Provides assertion functions, fixture creators, and utilities for testing
# the generate-agents.sh script. Loaded by all BATS test files.
#
# Updated: 2026-02-02
# Purpose: Scenario-based testing with size and data loss verification
#

# Get the directory containing the script under test
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# Exported for use by BATS test files that source this helper
# shellcheck disable=SC2034
GENERATE_SCRIPT="$SCRIPT_DIR/generate-agents.sh"
# shellcheck disable=SC2034
FIXTURES_DIR="$SCRIPT_DIR/test/fixtures"

# Load bats helper libraries if available
if [[ -d "$SCRIPT_DIR/test/test_helper/bats-support" ]]; then
    load 'test_helper/bats-support/load'
fi
if [[ -d "$SCRIPT_DIR/test/test_helper/bats-assert" ]]; then
    load 'test_helper/bats-assert/load'
fi

# =============================================================================
# SIZE ENFORCEMENT (CRITICAL)
# =============================================================================

# HARD LIMIT: Progressive mode must be under this
MAX_PROGRESSIVE_LINES=100

# assert_progressive_size <file>
# Verifies that a generated file is within the progressive mode size limit.
# Arguments:
#   $1 - Path to the file to check
# Returns: 0 if within limit, 1 if exceeds limit
assert_progressive_size() {
    local file="$1"
    local line_count
    line_count=$(wc -l < "$file" | tr -d ' ')
    if [[ "$line_count" -gt "$MAX_PROGRESSIVE_LINES" ]]; then
        echo "FAIL: Progressive mode generated $line_count lines (max: $MAX_PROGRESSIVE_LINES)" >&2
        echo "ERROR: Files this large defeat the purpose of AI guidance." >&2
        return 1
    fi
}

# =============================================================================
# DATA LOSS VERIFICATION (CRITICAL)
# =============================================================================

# count_unique_content_lines <file>
# Counts unique non-empty, non-whitespace lines for content comparison.
# Arguments:
#   $1 - Path to the file to analyze
# Returns: Count via stdout
count_unique_content_lines() {
    local file="$1"
    grep -v '^[[:space:]]*$' "$file" | sort -u | wc -l | tr -d ' '
}

# assert_content_preserved <file> <marker> [context]
# Verifies that a specific content marker exists in the file.
# Arguments:
#   $1 - Path to the file to check
#   $2 - String marker that must be present
#   $3 - (optional) Context description for error messages
# Returns: 0 if found, 1 if missing
assert_content_preserved() {
    local file="$1"
    local marker="$2"
    local context="${3:-unknown operation}"

    if ! grep -q "$marker" "$file"; then
        echo "FAIL: Content lost in $context" >&2
        echo "  Missing: $marker" >&2
        return 1
    fi
}

# =============================================================================
# FIXTURE HELPERS
# =============================================================================

# create_agents_with_markers <path> [language] [type] [mode]
# Creates a minimal valid AGENTS.md WITH framework markers (v1.2.0+ style).
# Includes project-specific content after the end marker for upgrade testing.
# Arguments:
#   $1 - Directory path where AGENTS.md will be created
#   $2 - (optional) Language, default: "go"
#   $3 - (optional) Project type, default: "cli-tools"
#   $4 - (optional) Mode, default: "progressive"
# Returns: 0 on success
# Side effects: Creates directory and AGENTS.md file
create_agents_with_markers() {
    local path="$1"
    local lang="${2:-go}"
    local type="${3:-cli-tools}"
    local mode="${4:-progressive}"

    mkdir -p "$path"
    cat > "$path/AGENTS.md" << EOF
# AI Agent Guidelines - TestProject

> **Generated by**: [golden-agents](https://github.com/bordenet/golden-agents) v1.2.1 (${mode})
> **Last Updated**: 2026-02-01
> **Languages**: ${lang}
> **Type**: ${type}

Self-contained. Minimal high-signal tokens.
<!-- GOLDEN:framework:start -->

---

## Superpowers Integration

At the START of every conversation, run:

\`\`\`bash
node ~/.codex/superpowers-augment/superpowers-augment.js bootstrap
\`\`\`

<!-- GOLDEN:framework:end -->

---

## Project-Specific Rules

<!-- Add project-specific guidance below this line -->

### My Custom Rule
Always use feature branches for new work.

### Team Conventions
- PR requires 2 approvals
- Use conventional commits
EOF
}

# create_agents_without_markers <path>
# Creates an AGENTS.md WITHOUT framework markers (pre-v1.2.0 style).
# Used to test --adopt workflow.
# Arguments:
#   $1 - Directory path where AGENTS.md will be created
# Returns: 0 on success
create_agents_without_markers() {
    local path="$1"
    mkdir -p "$path"
    cat > "$path/AGENTS.md" << EOF
# AI Agent Guidelines - TestProject

## Some guidance
This file has no markers and was created before v1.2.0.

## Project Rules
- Do something
- Do something else
EOF
}

# create_agents_full_mode <path> [language]
# Creates an AGENTS.md with full mode header (legacy, deprecated).
# Used to test upgrade from full mode to progressive mode.
# Arguments:
#   $1 - Directory path where AGENTS.md will be created
#   $2 - (optional) Language, default: "go"
# Returns: 0 on success
create_agents_full_mode() {
    local path="$1"
    local lang="${2:-go}"

    mkdir -p "$path"
    cat > "$path/AGENTS.md" << EOF
# AI Agent Guidelines - TestProject

> **Generated by**: [golden-agents](https://github.com/bordenet/golden-agents) v1.2.1
> **Last Updated**: 2026-02-01
> **Languages**: ${lang}
> **Type**: cli-tools

<!-- GOLDEN:framework:start -->
## Framework content (full mode)
<!-- GOLDEN:framework:end -->

## Project-Specific Rules
Custom content here.
EOF
}

# create_bloated_fixture <path> <line_count>
# Creates a bloated AGENTS.md to test size reduction.
# Simulates old full-mode files that need deduplication.
# Arguments:
#   $1 - Directory path where AGENTS.md will be created
#   $2 - Number of lines to generate
# Returns: 0 on success
create_bloated_fixture() {
    local path="$1"
    local lines="${2:-600}"
    local lang="${3:-go}"

    mkdir -p "$path"
    {
        echo "# AI Agent Guidelines"
        echo ""
        echo "> **Auto-generated by Golden Agents Framework**"
        echo "> **Languages**: ${lang}"
        echo "> **Type**: cli-tools"
        echo ""
        echo "<!-- GOLDEN:framework:start -->"

        # Generate bloated framework content
        for i in $(seq 1 "$lines"); do
            echo "Framework line $i with some padding content here"
        done

        echo "<!-- GOLDEN:framework:end -->"
        echo ""
        echo "## Project-Specific Rules"
        echo ""
        echo "### Custom Rule 1"
        echo "UNIQUE_MARKER_CUSTOM_RULE_1"
        echo ""
        echo "### Custom Rule 2"
        echo "UNIQUE_MARKER_CUSTOM_RULE_2"
    } > "$path/AGENTS.md"
}

# create_bloated_agents_with_markers <path> [lines]
# Creates a bloated AGENTS.md WITH framework markers for self-manage testing.
# The file will exceed the 150-line threshold to trigger modular migration.
# Arguments:
#   $1 - Directory path where AGENTS.md will be created
#   $2 - (optional) Number of extra lines to add, default: 200
# Returns: 0 on success
create_bloated_agents_with_markers() {
    local dir="$1"
    local lines="${2:-200}"
    mkdir -p "$dir"
    cat > "$dir/AGENTS.md" << 'EOF'
# AI Agent Guidelines - Test Project

> **Generated by**: [golden-agents](https://github.com/bordenet/golden-agents) v1.4.0 (progressive)
> **Languages**: go
> **Type**: cli-tools

<!-- GOLDEN:framework:start -->
## Quality Gates
- Lint
- Build
- Test
<!-- GOLDEN:framework:end -->

## Project-Specific Rules
EOF
    # Add bloat lines to exceed 150-line threshold
    for i in $(seq 1 "$lines"); do
        echo "- Rule $i: Do something specific for this project" >> "$dir/AGENTS.md"
    done
}

# create_realistic_claude_md <path>
# Creates a realistic CLAUDE.md file for migration testing.
# Contains typical project guidance that would need to be migrated.
# Includes UNIQUE_MARKER_* strings for data loss verification.
# Arguments:
#   $1 - Directory path where CLAUDE.md will be created
# Returns: 0 on success
create_realistic_claude_md() {
    local path="$1"

    mkdir -p "$path"
    cat > "$path/CLAUDE.md" << 'EOF'
# Project AI Guidelines

> Last Updated: 2026-01-15

## Build Commands

```bash
npm run build
npm run test
npm run lint
```

## Architecture

This project uses a three-tier architecture:

1. **Frontend**: React with TypeScript
2. **Backend**: Go microservices
3. **Database**: PostgreSQL

UNIQUE_MARKER_ARCHITECTURE

## Development Conventions

### Git Workflow
- Feature branches from main
- PR requires 2 approvals
- Squash merge only

UNIQUE_MARKER_GIT_WORKFLOW

### Code Style
- Use Prettier for formatting
- ESLint for linting
- Go fmt for Go code

UNIQUE_MARKER_CODE_STYLE

## Testing Requirements

- Unit tests required for all new code
- Integration tests for API endpoints
- E2E tests for critical flows

UNIQUE_MARKER_TESTING

## AI Behavior Rules

- Never expose API keys
- Always use environment variables for secrets
- Check for security vulnerabilities before committing

UNIQUE_MARKER_AI_BEHAVIOR

## Custom Domain Knowledge

This is project-specific knowledge that must be preserved:
- The Validation Dashboard uses terminal UI
- Recipe Capture has three tiers
- AppLogger uses specific patterns

UNIQUE_MARKER_DOMAIN_KNOWLEDGE
EOF
}

# =============================================================================
# BASIC ASSERTIONS
# =============================================================================

# assert_file_contains <file> <pattern>
# Asserts that a file contains the specified pattern.
# Arguments:
#   $1 - Path to the file to check
#   $2 - Pattern to search for (grep-compatible)
# Returns: 0 if found, 1 if not found (with diagnostic output)
assert_file_contains() {
    local file="$1"
    local pattern="$2"
    if ! grep -q "$pattern" "$file"; then
        echo "FAIL: File '$file' does not contain: $pattern" >&2
        echo "File contents:" >&2
        cat "$file" >&2
        return 1
    fi
}

# assert_file_not_contains <file> <pattern>
# Asserts that a file does NOT contain the specified pattern.
# Arguments:
#   $1 - Path to the file to check
#   $2 - Pattern that should NOT be present
# Returns: 0 if not found, 1 if found
assert_file_not_contains() {
    local file="$1"
    local pattern="$2"
    if grep -q "$pattern" "$file"; then
        echo "FAIL: File '$file' should not contain: $pattern" >&2
        return 1
    fi
}

# assert_file_exists <file>
# Asserts that a file exists.
# Arguments:
#   $1 - Path to the file to check
# Returns: 0 if exists, 1 if not
assert_file_exists() {
    local file="$1"
    if [[ ! -f "$file" ]]; then
        echo "FAIL: File '$file' does not exist" >&2
        return 1
    fi
}

# assert_dir_exists <directory>
# Asserts that a directory exists.
# Arguments:
#   $1 - Path to the directory to check
# Returns: 0 if exists, 1 if not
assert_dir_exists() {
    local dir="$1"
    if [[ ! -d "$dir" ]]; then
        echo "FAIL: Directory '$dir' does not exist" >&2
        return 1
    fi
}

# get_line_count <file>
# Returns the line count of a file.
# Arguments:
#   $1 - Path to the file
# Returns: Line count via stdout
get_line_count() {
    local file="$1"
    wc -l < "$file" | tr -d ' '
}

# assert_line_count_between <file> <min> <max>
# Asserts that a file's line count is within the specified range.
# Arguments:
#   $1 - Path to the file to check
#   $2 - Minimum line count (inclusive)
#   $3 - Maximum line count (inclusive)
# Returns: 0 if within range, 1 if outside range
assert_line_count_between() {
    local file="$1"
    local min="$2"
    local max="$3"
    local count
    count=$(get_line_count "$file")
    if [[ "$count" -lt "$min" || "$count" -gt "$max" ]]; then
        echo "FAIL: File '$file' has $count lines, expected between $min and $max" >&2
        return 1
    fi
}

